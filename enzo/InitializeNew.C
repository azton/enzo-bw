/***********************************************************************
/
/  INITIALIZE A NEW SIMULATION
/
/  written by: Greg Bryan
/  date:       November, 1994
/  modified1:  Robert Harkness
/  date:       September 2004
/  modified2:  Stephen Skory
/  date:       May, 2008
/  modified3:  Alexei Kritsuk
/  date:       May, 2008
/
/  PURPOSE:
/
/  RETURNS: SUCCESS or FAIL
/
************************************************************************/
 
// This routine intializes a new simulation based on the parameter file.
 
 
#include <string.h>
#include <stdio.h>
 
#include "macros_and_parameters.h"
#include "typedefs.h"
#include "global_data.h"
#include "Fluxes.h"
#include "GridList.h"
#include "ExternalBoundary.h"
#include "Grid.h"
#include "Hierarchy.h"
#include "TopGridData.h"
#include "StarParticleData.h"
 
// Function prototypes
 
int WriteHierarchyStuff(FILE *fptr, HierarchyEntry *Grid,
                        char* base_name, int &GridID, FLOAT WriteTime);
int ReadParameterFile(FILE *fptr, TopGridData &MetaData, float *Initialdt);
int WriteParameterFile(FILE *fptr, TopGridData &MetaData);
void ConvertTotalEnergyToGasEnergy(HierarchyEntry *Grid);
int SetDefaultGlobalValues(TopGridData &MetaData);
int CommunicationPartitionGrid(HierarchyEntry *Grid);
int CommunicationBroadcastValue(int *Value, int BroadcastProcessor);
 
// Initialization function prototypes
 
int ShockTubeInitialize(FILE *fptr, FILE *Outfptr, HierarchyEntry &TopGrid);
int WavePoolInitialize(FILE *fptr, FILE *Outfptr, HierarchyEntry &TopGrid,
		       TopGridData &MetaData);
int ShockPoolInitialize(FILE *fptr, FILE *Outfptr, HierarchyEntry &TopGrid,
			TopGridData &MetaData);
int DoubleMachInitialize(FILE *fptr, FILE *Outfptr, HierarchyEntry &TopGrid,
			TopGridData &MetaData, ExternalBoundary &Exterior);
int ShockInABoxInitialize(FILE *fptr, FILE *Outfptr, HierarchyEntry &TopGrid,
			  TopGridData &MetaData, ExternalBoundary &Exterior);
int ImplosionInitialize(FILE *fptr, FILE *Outfptr, HierarchyEntry &TopGrid,
                        TopGridData &MetaData);
int RotatingCylinderInitialize(FILE *fptr, FILE *Outfptr, HierarchyEntry &TopGrid,
			       TopGridData &MetaData);
int KHInitialize(FILE *fptr, FILE *Outfptr, HierarchyEntry &TopGrid,
                          TopGridData &MetaData);
int NohInitialize(FILE *fptr, FILE *Outfptr, HierarchyEntry &TopGrid,
                          TopGridData &MetaData);
int SedovBlastInitialize(FILE *fptr, FILE *Outfptr, HierarchyEntry &TopGrid,
                          TopGridData &MetaData);
int RadiatingShockInitialize(FILE *fptr, FILE *Outfptr, HierarchyEntry &TopGrid,
			     TopGridData &MetaData);
int ZeldovichPancakeInitialize(FILE *fptr, FILE *Outfptr,
			       HierarchyEntry &TopGrid);
int PressurelessCollapseInitialize(FILE *fptr, FILE *Outfptr,
			       HierarchyEntry &TopGrid, TopGridData &MetaData);
int AdiabaticExpansionInitialize(FILE *fptr, FILE *Outfptr,
				 HierarchyEntry &TopGrid);
int TestGravityInitialize(FILE *fptr, FILE *Outfptr, HierarchyEntry &TopGrid,
			  TopGridData &MetaData);
int TestOrbitInitialize(FILE *fptr, FILE *Outfptr, HierarchyEntry &TopGrid,
                        TopGridData &MetaData);
int GalaxySimulationInitialize(FILE *fptr, FILE *Outfptr, HierarchyEntry &TopGrid,
                        TopGridData &MetaData);
int TestGravitySphereInitialize(FILE *fptr, FILE *Outfptr,
			       HierarchyEntry &TopGrid, TopGridData &MetaData);
int SphericalInfallInitialize(FILE *fptr, FILE *Outfptr,
			      HierarchyEntry &TopGrid, TopGridData &MetaData);
int GravityEquilibriumTestInitialize(FILE *fptr, FILE *Outfptr,
			      HierarchyEntry &TopGrid, TopGridData &MetaData);
int CoolingTestInitialize(FILE *fptr, FILE *Outfptr,
			      HierarchyEntry &TopGrid, TopGridData &MetaData);
int CollapseTestInitialize(FILE *fptr, FILE *Outfptr,
			  HierarchyEntry &TopGrid, TopGridData &MetaData);
int TestGravityMotion(FILE *fptr, FILE *Outfptr, HierarchyEntry &TopGrid,
			  TopGridData &MetaData);
int SupernovaRestartInitialize(FILE *fptr, FILE *Outfptr,
			       HierarchyEntry &TopGrid, TopGridData &MetaData,
			       ExternalBoundary &Exterior);
int ProtostellarCollapseInitialize(FILE *fptr, FILE *Outfptr,
				   HierarchyEntry &TopGrid,
				   TopGridData &MetaData);
 
int CosmologySimulationInitialize(FILE *fptr, FILE *Outfptr,
                                  HierarchyEntry &TopGrid,
                                  TopGridData &MetaData);
int CosmologySimulationReInitialize(HierarchyEntry *TopGrid,
                                    TopGridData &MetaData);
 
int NestedCosmologySimulationInitialize(FILE *fptr, FILE *Outfptr,
                                        HierarchyEntry &TopGrid,
                                        TopGridData &MetaData);
int NestedCosmologySimulationReInitialize(HierarchyEntry *TopGrid,
                                          TopGridData &MetaData);
 
int TurbulenceSimulationInitialize(FILE *fptr, FILE *Outfptr,
                                  HierarchyEntry &TopGrid,
                                  TopGridData &MetaData);
int TurbulenceSimulationReInitialize(HierarchyEntry *TopGrid,
                                    TopGridData &MetaData);
 
int TracerParticleCreation(FILE *fptr, HierarchyEntry &TopGrid,
                           TopGridData &MetaData);
 
#ifdef RAD_HYDRO
int RadHydroConstTestInitialize(FILE *fptr, FILE *Outfptr,
				HierarchyEntry &TopGrid,
				TopGridData &MetaData, int local);
int RadHydroGreyMarshakWaveInitialize(FILE *fptr, FILE *Outfptr,
				      HierarchyEntry &TopGrid,
				      TopGridData &MetaData, int local);
int RadHydroPulseTestInitialize(FILE *fptr, FILE *Outfptr,
				HierarchyEntry &TopGrid,
				TopGridData &MetaData, int local);
int RadHydroRadShockInitialize(FILE *fptr, FILE *Outfptr,
			       HierarchyEntry &TopGrid,
			       TopGridData &MetaData, int local);
int RadHydroStreamTestInitialize(FILE *fptr, FILE *Outfptr,
				 HierarchyEntry &TopGrid,
				 TopGridData &MetaData, int local);
int RHIonizationTestInitialize(FILE *fptr, FILE *Outfptr,
			       HierarchyEntry &TopGrid,
			       TopGridData &MetaData, int local);
int RHIonizationClumpInitialize(FILE *fptr, FILE *Outfptr,
				HierarchyEntry &TopGrid,
				TopGridData &MetaData, int local);
int RHIonizationSteepInitialize(FILE *fptr, FILE *Outfptr,
				HierarchyEntry &TopGrid,
				TopGridData &MetaData, int local);
int CosmoIonizationInitialize(FILE *fptr, FILE *Outfptr,
			      HierarchyEntry &TopGrid,
			      TopGridData &MetaData, int local);


int FSMultiSourceInitialize(FILE *fptr, FILE *Outfptr,
			    HierarchyEntry &TopGrid,
			    TopGridData &MetaData, int local);

int DualCosmoIonizationInitialize(FILE *fptr, FILE *Outfptr,
				  HierarchyEntry &TopGrid,
				  TopGridData &MetaData, int local);
int DualRHIonizationTestInitialize(FILE *fptr, FILE *Outfptr,
				   HierarchyEntry &TopGrid,
				   TopGridData &MetaData, int local);
int DualRadStreamTestInitialize(FILE *fptr, FILE *Outfptr,
				HierarchyEntry &TopGrid,
				TopGridData &MetaData, int local);
int DualRadConstTestInitialize(FILE *fptr, FILE *Outfptr,
			       HierarchyEntry &TopGrid,
			       TopGridData &MetaData, int local);
#endif


#ifdef MEM_TRACE
Eint64 mused(void);
#endif
 
// Character strings
 
char outfilename[] = "amr.out";
 
 
 
 
int InitializeNew(char *filename, HierarchyEntry &TopGrid,
		  TopGridData &MetaData, ExternalBoundary &Exterior,
		  float *Initialdt)
{
 
  // Declarations
 
  FILE *fptr, *BCfptr, *Outfptr;
  float Dummy[MAX_DIMENSION];
  int dim, i;

#ifdef MEM_TRACE
    Eint64 MemInUse;
#endif
 
 
  for (dim = 0; dim < MAX_DIMENSION; dim++)
    Dummy[dim] = 0.0;
 
  // Open parameter file
 
  if ((fptr = fopen(filename, "r")) == NULL) {
    fprintf(stderr, "Error opening parameter file.\n");
    return FAIL;
  }
 
  // Open output file
 
  if (MyProcessorNumber == ROOT_PROCESSOR)
    if ((Outfptr = fopen(outfilename, "w")) == NULL) {
      fprintf(stderr, "Error opening parameter output file %s\n", outfilename);
      return FAIL;
    }
 
  // set the default MetaData values
 
  SetDefaultGlobalValues(MetaData);
 
  // Read the MetaData/global values from the Parameter file
 
  if (ReadParameterFile(fptr, MetaData, Initialdt) == FAIL) {
    fprintf(stderr, "Error in ReadParameterFile.\n");
    return FAIL;
  }
 
  // Set the number of particle attributes, if left unset
 
  if (NumberOfParticleAttributes == INT_UNDEFINED)
    if (StarParticleCreation || StarParticleFeedback)
      NumberOfParticleAttributes = 3;
    else
      NumberOfParticleAttributes = 0;
 
  // Give unset parameters their default values
 
  for (dim = 0; dim < MAX_DIMENSION; dim++) {
    if (RefineRegionLeftEdge[dim] == FLOAT_UNDEFINED)
      RefineRegionLeftEdge[dim]   = DomainLeftEdge[dim];
    if (RefineRegionRightEdge[dim] == FLOAT_UNDEFINED)
      RefineRegionRightEdge[dim]  = DomainRightEdge[dim];
    if (MetaData.MovieRegionLeftEdge[dim] == FLOAT_UNDEFINED)
      MetaData.MovieRegionLeftEdge[dim]   = DomainLeftEdge[dim];
    if (MetaData.MovieRegionRightEdge[dim] == FLOAT_UNDEFINED)
      MetaData.MovieRegionRightEdge[dim]  = DomainRightEdge[dim];
  }
 
  // If the problem reads in a restart dump, then skip over the following
 
  if (ProblemType != 40) {
 
  // Error check the rank
 
  if (MetaData.TopGridRank < 0 || MetaData.TopGridRank > 3) {
    fprintf(stderr, "TopGridRank = %"ISYM" ill defined.\n", MetaData.TopGridRank);
    return FAIL;
  }
 
  // Error check the dimensions and at the same time add ghost zones
 
  for (dim = 0; dim < MetaData.TopGridRank; dim++) {
    if (MetaData.TopGridDims[dim] < 1 || MetaData.TopGridDims[dim] > 8192) {
      fprintf(stderr, "TopGridDims[%"ISYM"] = %"ISYM" ill defined.\n", dim,
	      MetaData.TopGridDims[dim]);
      return FAIL;
    }
    MetaData.TopGridDims[dim] = (MetaData.TopGridDims[dim] > 1) ?
                     MetaData.TopGridDims[dim] + 2*DEFAULT_GHOST_ZONES : 1;
  }
 
  // Create the top grid, prepare it, set the time and parameters
 
  TopGrid.GridData = new grid;
 
  TopGrid.GridData->PrepareGrid(MetaData.TopGridRank, MetaData.TopGridDims,
				DomainLeftEdge, DomainRightEdge,
				MetaData.NumberOfParticles);
  TopGrid.GridData->SetTime(MetaData.Time);
  TopGrid.GridData->SetHydroParameters(MetaData.CourantSafetyNumber,
				       MetaData.PPMFlatteningParameter,
				       MetaData.PPMDiffusionParameter,
				       MetaData.PPMSteepeningParameter);
  TopGrid.GridData->SetGravityParameters(MetaData.GravityBoundary);
 
  // Repair TopGridDims (subtract ghost zones added earlier)
 
  for (dim = 0; dim < MetaData.TopGridRank; dim++)
    MetaData.TopGridDims[dim] = max(MetaData.TopGridDims[dim] -
				    2*DEFAULT_GHOST_ZONES, 1);
 
  // Set TopGrid Hierarchy Entry
 
  TopGrid.NextGridThisLevel = NULL;  // always true
  TopGrid.ParentGrid        = NULL;  // always true
  TopGrid.NextGridNextLevel = NULL;  // can be reset by initializer
 
  } // end: if (ProblemType != 40)
 
  // Call problem initializer

#ifdef MEM_TRACE
    MemInUse = mused();
    fprintf(memtracePtr, "Call problem init  %16"ISYM" \n", MemInUse);
#endif
 
  if (ProblemType == 0) {
    fprintf(stderr, "No problem specified.\n");
    return FAIL;
  }
 
  int ret = INT_UNDEFINED;
 
  if (debug)
    printf("InitializeNew: Starting problem initialization.\n");
 
  // 1) Shocktube problem
 
  if (ProblemType == 1)
    ret = ShockTubeInitialize(fptr, Outfptr, TopGrid);
 
  // 2) Wave pool
 
  if (ProblemType == 2)
    ret = WavePoolInitialize(fptr, Outfptr, TopGrid, MetaData);
 
  // 3) Shock pool
 
  if (ProblemType == 3)
    ret = ShockPoolInitialize(fptr, Outfptr, TopGrid, MetaData);
 
  // 4) Double Mach reflection
 
  if (ProblemType == 4)
    ret = DoubleMachInitialize(fptr, Outfptr, TopGrid, MetaData, Exterior);
 
  // 5) ShockInABox
 
  if (ProblemType == 5)
    ret = ShockInABoxInitialize(fptr, Outfptr, TopGrid, MetaData, Exterior);
 
  // 6) Implosion
 
  if (ProblemType == 6)
    ret = ImplosionInitialize(fptr, Outfptr, TopGrid, MetaData);
 
  // 7) SedovBlast
 
  if (ProblemType == 7)
    ret = SedovBlastInitialize(fptr, Outfptr, TopGrid, MetaData);

  // 8) KH Instability

  if (ProblemType == 8)
    ret = KHInitialize(fptr, Outfptr, TopGrid, MetaData);

  // 9) 2D/3D Noh Problem

  if (ProblemType == 9)
    ret = NohInitialize(fptr, Outfptr, TopGrid, MetaData);

  // 10) RotatingCylinder
 
  if (ProblemType == 10)
    ret = RotatingCylinderInitialize(fptr, Outfptr, TopGrid, MetaData);

  // 11) RadiatingShock
 
  if (ProblemType == 11)
    ret = RadiatingShockInitialize(fptr, Outfptr, TopGrid, MetaData);
 
  // 20) Zeldovich Pancake
 
  if (ProblemType == 20)
    ret = ZeldovichPancakeInitialize(fptr, Outfptr, TopGrid);
 
  // 21) 1D Pressureless collapse
 
  if (ProblemType == 21)
    ret = PressurelessCollapseInitialize(fptr, Outfptr, TopGrid, MetaData);
 
  // 22) Adiabatic expansion
 
  if (ProblemType == 22)
    ret = AdiabaticExpansionInitialize(fptr, Outfptr, TopGrid);
 
  // 23) GravityTest
 
  if (ProblemType == 23)
    ret = TestGravityInitialize(fptr, Outfptr, TopGrid, MetaData);
 
  // 24) Spherical Infall
 
  if (ProblemType == 24)
    ret = SphericalInfallInitialize(fptr, Outfptr, TopGrid, MetaData);
 
  // 25) TestGravitySphere
 
  if (ProblemType == 25)
    ret = TestGravitySphereInitialize(fptr, Outfptr, TopGrid, MetaData);
 
  // 26) GravityEquilibriumTest
 
  if (ProblemType == 26)
    ret = GravityEquilibriumTestInitialize(fptr, Outfptr, TopGrid, MetaData);
 
  // 27) CollapseTest
 
  if (ProblemType == 27)
    ret = CollapseTestInitialize(fptr, Outfptr, TopGrid, MetaData);
 
  // 28) TestGravityMotion
 
  if (ProblemType == 28)
    ret = TestGravityMotion(fptr, Outfptr, TopGrid, MetaData);

  // 29) TestOrbit
  if (ProblemType == 29)
    ret = TestOrbitInitialize(fptr, Outfptr, TopGrid, MetaData);
 
  // 30) Cosmology Simulation
 
  if (ProblemType == 30) {
    if (PartitionNestedGrids) {
      ret = NestedCosmologySimulationInitialize(fptr, Outfptr, TopGrid, MetaData);
    } else {
      ret = CosmologySimulationInitialize(fptr, Outfptr, TopGrid, MetaData);
    }
  }
 
  // 31) GalaxySimulation
  if (ProblemType == 31)
    ret = GalaxySimulationInitialize(fptr, Outfptr, TopGrid, MetaData);

  // 40) Supernova Explosion from restart
 
  if (ProblemType == 40)
    ret = SupernovaRestartInitialize(fptr, Outfptr, TopGrid, MetaData,
				     Exterior);
 
  // 60) Turbulence Simulation.
 
  if (ProblemType == 60)
    ret = TurbulenceSimulationInitialize(fptr, Outfptr, TopGrid, MetaData);

  // 61) Protostellar Collapse
  if (ProblemType == 61)
    ret = ProtostellarCollapseInitialize(fptr, Outfptr, TopGrid, MetaData);
 
  // 62) Cooling test problem
  if (ProblemType == 62)
    ret = CoolingTestInitialize(fptr, Outfptr, TopGrid, MetaData);

#ifdef RAD_HYDRO
  // 200) Radiation-Hydrodynamics test 1 -- constant fields
  if ((ProblemType == 200) || (ProblemType == 216)) 
    if (ImplicitProblem == 4) {
      ret = DualRadConstTestInitialize(fptr, Outfptr, TopGrid, MetaData, 0);
    } else {
      ret = RadHydroConstTestInitialize(fptr, Outfptr, TopGrid, MetaData, 0);
    }

  // 201) Radiation-Hydrodynamics test 2 -- stream test
  if (ProblemType == 201)
    if (ImplicitProblem == 4) {
      ret = DualRadStreamTestInitialize(fptr, Outfptr, TopGrid, MetaData, 0);
    } else {
      ret = RadHydroStreamTestInitialize(fptr, Outfptr, TopGrid, MetaData, 0);
    }

  // 202) Radiation-Hydrodynamics test 3 -- pulse test
  if (ProblemType == 202)
    ret = RadHydroPulseTestInitialize(fptr, Outfptr, TopGrid, MetaData, 0);

  // 203) Radiation-Hydrodynamics test 4 -- grey Marshak test
  if (ProblemType == 203)
    ret = RadHydroGreyMarshakWaveInitialize(fptr, Outfptr, TopGrid, MetaData, 0);

  // 204/205) Radiation-Hydrodynamics test 5 -- radiating shock test
  if ( (ProblemType == 204) || (ProblemType == 205) )
    ret = RadHydroRadShockInitialize(fptr, Outfptr, TopGrid, MetaData, 0);

  // 210/211) Radiation-Hydrodynamics tests 10 & 11 -- HI ionization (static)
  if ((ProblemType == 210) || (ProblemType == 211))
    if (ImplicitProblem == 4) {
      ret = DualRHIonizationTestInitialize(fptr, Outfptr, TopGrid, MetaData, 0);
    } else {
      ret = RHIonizationTestInitialize(fptr, Outfptr, TopGrid, MetaData, 0);
    }

  // 212) Radiation-Hydrodynamics test 12 -- HI ionization of a clump
  if (ProblemType == 212)
    ret = RHIonizationClumpInitialize(fptr, Outfptr, TopGrid, MetaData, 0);

  // 213) Radiation-Hydrodynamics test 13 -- HI ionization of a steep region
  if (ProblemType == 213)
    ret = RHIonizationSteepInitialize(fptr, Outfptr, TopGrid, MetaData, 0);

  // 214/215) Radiation-Hydrodynamics tests 14 & 15 -- Cosmological HI ioniz.
  if ((ProblemType == 214) || (ProblemType == 215))
    if (ImplicitProblem == 4) {
      ret = DualCosmoIonizationInitialize(fptr, Outfptr, TopGrid, MetaData, 0);
    } else {
      ret = CosmoIonizationInitialize(fptr, Outfptr, TopGrid, MetaData, 0);
    }

  // 250) Multi-source free-streaming radiation test
  if (ProblemType == 250) 
    ret = FSMultiSourceInitialize(fptr, Outfptr, TopGrid, MetaData, 0);
#endif

  // Insert new problem intializer here...
 
  if (ret == INT_UNDEFINED) {
    fprintf(stderr, "Problem Type %"ISYM" undefined.\n", ProblemType);
    return FAIL;
  }
 
  if (ret == FAIL) {
    fprintf(stderr, "Error in problem initialization.\n");
    return FAIL;
  }
 
  if (debug)
    printf("InitializeNew: Finished problem initialization.\n");
 
  // Do some error checking
 
  if (MetaData.StopTime == FLOAT_UNDEFINED) {
    fprintf(stderr, "StopTime never set.\n");
    return FAIL;
  }

#ifdef MEM_TRACE
    MemInUse = mused();
    fprintf(memtracePtr, "1st Initialization done %16"ISYM" \n", MemInUse);
#endif

 
  if (debug)
    printf("Initialize Exterior\n");
 
  // Initialize the exterior (unless it was set in the problem initializer)
 
  if (Exterior.AmIPrepared() == FALSE) {

    Exterior.Prepare(TopGrid.GridData);   // set rank and dims

    if (MetaData.BoundaryConditionName != NULL) {

      if ((BCfptr = fopen(MetaData.BoundaryConditionName, "r")) == NULL) {
	fprintf(stderr, "Error opening BC file: %s\n",
		MetaData.BoundaryConditionName);
	return FAIL;
      }

      fprintf(stderr, "Opened BC file mode r\n");

      if (Exterior.ReadExternalBoundary(BCfptr) == FAIL) {
	fprintf(stderr, "Error in ReadExternalBoundary.\n");
	return FAIL;
      }
      fclose(BCfptr);
    }
 
    else {

      if (debug) {
        fprintf(stderr, "InitializeExternalBoundaryFace\n");
      }

      SimpleConstantBoundary = TRUE;

      for (dim = 0; dim < MetaData.TopGridRank; dim++) {
        if (MetaData.LeftFaceBoundaryCondition[dim] != periodic ||
            MetaData.RightFaceBoundaryCondition[dim] != periodic) {
          SimpleConstantBoundary = FALSE;
        }
      }

      if (debug) {
        if (SimpleConstantBoundary) {
          fprintf(stderr, "SimpleConstantBoundary TRUE\n");
        } else {
          fprintf(stderr, "SimpleConstantBoundary FALSE\n");
        }
      }
        
      for (dim = 0; dim < MetaData.TopGridRank; dim++)
	if (Exterior.InitializeExternalBoundaryFace(dim,
				    MetaData.LeftFaceBoundaryCondition[dim],
				    MetaData.RightFaceBoundaryCondition[dim],
				    Dummy, Dummy)
	    == FAIL) {
	  fprintf(stderr, "Error in InitializeExternalBoundaryFace.\n");
	  return FAIL;
	}
 
      // Initialize particle boundary conditions
 
      Exterior.InitializeExternalBoundaryParticles(
					  MetaData.ParticleBoundaryType);
 
    }  // end: if (MetaData.BoundaryConditionName != NULL)
 
  }  // end of set Exterior

#ifdef MEM_TRACE
    MemInUse = mused();
    fprintf(memtracePtr, "Exterior set  %16"ISYM" \n", MemInUse);
#endif

  if (debug) {
    fprintf(stderr, "End of set exterior\n");
  }
 
  // Set values that were left undefined (above)
 
  if (MetaData.TimeLastDataDump == FLOAT_UNDEFINED)
    MetaData.TimeLastDataDump = MetaData.Time - MetaData.dtDataDump*1.00001;
  if (MetaData.TimeLastHistoryDump == FLOAT_UNDEFINED)
    MetaData.TimeLastHistoryDump = MetaData.Time - MetaData.dtHistoryDump;
  if (MetaData.TimeLastMovieDump == FLOAT_UNDEFINED)
    MetaData.TimeLastMovieDump = MetaData.Time - MetaData.dtMovieDump;
 
  if (MetaData.TimeLastTracerParticleDump == FLOAT_UNDEFINED)
    MetaData.TimeLastTracerParticleDump =
                           MetaData.Time - MetaData.dtTracerParticleDump;
 
  if (MetaData.CycleLastDataDump == INT_UNDEFINED)
    MetaData.CycleLastDataDump = MetaData.CycleNumber -
                                 MetaData.CycleSkipDataDump;
  if (MetaData.CycleLastHistoryDump == INT_UNDEFINED)
    MetaData.CycleLastHistoryDump = MetaData.CycleNumber -
                                    MetaData.CycleSkipHistoryDump;
 
  // Make changes required for Zeus solver, and turn the TotalEnergy
  // variable (should be renamed just Energy) into GasEnergy
 
  if (HydroMethod == Zeus_Hydro &&
      ProblemType != 10 &&  // BWO (Rotating cylinder)
      ProblemType != 11 &&  // BWO (radiating shock)
      ProblemType != 20 &&
      ProblemType != 27 &&
      ProblemType != 30 &&
      ProblemType != 31 &&  // BWO (isolated galaxies)
      ProblemType != 60) //AK
    ConvertTotalEnergyToGasEnergy(&TopGrid);
 
  // If using StarParticles, set the number to zero 
  // (assuming it hasn't already been set)
  if (NumberOfStarParticles == NULL)
    if (StarParticleCreation || StarParticleFeedback)
      NumberOfStarParticles = 0;
 
  // Convert minimum initial overdensity for refinement to mass
  // (unless MinimumMass itself was actually set)
 
  for (i = 0; i < MAX_FLAGGING_METHODS; i++)
    if (MinimumMassForRefinement[i] == FLOAT_UNDEFINED) {
      MinimumMassForRefinement[i] = MinimumOverDensityForRefinement[i];
      for (dim = 0; dim < MetaData.TopGridRank; dim++)
	MinimumMassForRefinement[i] *=
	  (DomainRightEdge[dim]-DomainLeftEdge[dim])/
	  float(MetaData.TopGridDims[dim]);
    }
 
  // Check for the creation of tracer particles
  // Tracer particles will not be created at this point if ||rgio in ON
 
  if (TracerParticleCreation(fptr, TopGrid, MetaData) == FAIL) {
    fprintf(stderr, "Error in TracerParticleCreation\n");
    return FAIL;
  }
 
  // Write the MetaData/global values to the Parameter file
 
  if (MyProcessorNumber == ROOT_PROCESSOR)
    if (WriteParameterFile(Outfptr, MetaData) == FAIL) {
      fprintf(stderr, "Error in WriteParameterFile.\n");
      return FAIL;
    }
 
  if (debug)
    printf("InitializeNew: Initial grid hierarchy set\n");
 
  // Walk the grids
 
  HierarchyEntry *CurrentGrid;
  FLOAT WT = -1.0;
  int GP = 1;
  int gridcounter = 0;
 
  CurrentGrid = &TopGrid;
 
  while (CurrentGrid != NULL) {
 
    // WriteHierarchyStuff(stderr, CurrentGrid, "UUUU", GP, WT);
 
    if (debug)
      printf("InitializeNew: Partition Initial Grid %"ISYM"\n", gridcounter);
 
    CommunicationPartitionGrid(CurrentGrid);
 
    gridcounter++;
 
    CurrentGrid = CurrentGrid->NextGridNextLevel;
 
  }
 
  // For problem 30, using ParallelGridIO,
  // read in data only after partitioning the grid
 
  if (debug)
    if (ParallelRootGridIO == TRUE && ProblemType == 30) {
      if (PartitionNestedGrids) {
        printf("InitializeNew: Re-initialize NestedCosmologySimulation\n");
      } else {
        printf("InitializeNew: Re-initialize CosmologySimulation\n");
      }
    }

#ifdef MEM_TRACE
    MemInUse = mused();
    fprintf(memtracePtr, "Before 2nd pass  %16"ISYM" \n", MemInUse);
#endif
 
  if (ParallelRootGridIO == TRUE && ProblemType == 30) {
    if (PartitionNestedGrids) {
      if (NestedCosmologySimulationReInitialize(&TopGrid, MetaData) == FAIL) {
        fprintf(stderr, "Error in NestedCosmologySimulationReInitialize.\n");
        return FAIL;
      }
    } else {
      if (CosmologySimulationReInitialize(&TopGrid, MetaData) == FAIL) {
        fprintf(stderr, "Error in CosmologySimulationReInitialize.\n");
        return FAIL;
      }
    }
  }
 
#ifdef MEM_TRACE
    MemInUse = mused();
    fprintf(memtracePtr, "After 2nd pass  %16"ISYM" \n", MemInUse);
#endif
 
  // For problem 60, using ParallelGridIO, read in data only after
  // partitioning grid.
 
  if (ParallelRootGridIO == TRUE && ProblemType == 60)
    if (TurbulenceSimulationReInitialize(&TopGrid, MetaData) == FAIL) {
      fprintf(stderr, "Error in TurbulenceSimulationReInitialize.\n");
      return FAIL;
    }
 
 
 
  // Close parameter files
 
  fclose(fptr);
 
  if (MyProcessorNumber == ROOT_PROCESSOR)
    fclose(Outfptr);

#ifdef MEM_TRACE
    MemInUse = mused();
    fprintf(memtracePtr, "Exit X_Init  %16"ISYM" \n", MemInUse);
#endif

#ifdef MISCOUNT
  // 2006-12-11 Skory bug fix for star particle miscounts
  // Added the following line:

  CommunicationBroadcastValue(&MetaData.NumberOfParticles, ROOT_PROCESSOR);
#endif
 
  return SUCCESS;
 
}
 
 
 
 
void ConvertTotalEnergyToGasEnergy(HierarchyEntry *Grid)
{
  if (Grid != NULL) {
    Grid->GridData->ConvertTotalEnergyToGasEnergy();
    ConvertTotalEnergyToGasEnergy(Grid->NextGridThisLevel);
    ConvertTotalEnergyToGasEnergy(Grid->NextGridNextLevel);
  }
}
