/***********************************************************************
/
/  EVOLVE LEVEL FUNCTION
/
/  written by: Greg Bryan
/  date:       November, 1994
/  modified1:  February, 1995 by GB
/              Overhauled to make sure that all the subgrid's of a grid
/              advance with in lock step (i.e. with the same timestep and
/              in order).  This was done to allow a subgrid to get it's
/              boundary values from another subgrid (with the same parent).
/              Previously, a subgrid' BVs were always interpolated from its
/              parent.
/  modified2:  August, 1995 by GB
/                1) All grids on a level are processed at the same time
/                 (rather than all the subgrids of one parent).
/                2) C routines are called to loop over subgrids
/                 (so parallelizing C compilers can be used).
/                3) Subgrid timesteps are not constant over top grid step.
/              June, 1999 by GB -- Clean up somewhat
/
/  modified3:  August, 2001 by Alexei Kritsuk
/                Added 2nd call of PrepareDensityField() to compute
/                grav. potential (to be written with other baryon fields).
/  modified4:  January, 2004 by Alexei Kritsuk
/                Added support for RandomForcing
/  modified5:  February, 2006 by Daniel Reynolds
/                Added PotentialBdry to EvolveLevel and 
/                PrepareDensityField calls, so that it can be used
/                within computing isolating BCs for self-gravity.
/  modified6:  January, 2007 by Robert Harkness
/                Group and in-core i/o
/  modified7:  December, 2007 by Robert Harkness
/                Optional StaticSiblingList for root grid
/  modified8:  June, 2009 by Geoffrey So
/                Add emissivity field & rad hydro
/
/  PURPOSE:
/    This routine is the main grid evolution function.  It assumes that the
/    grids of level-1 have already been advanced by dt (passed
/    in the argument) and that their boundary values are properly set.
/    We then perform a complete update on all grids on level, including:
/       - for each grid: set the boundary values from parent/subgrids
/       - for each grid: get a list of its subgrids
/       - determine the timestep based on the minimum timestep for all grids
/       - subcycle over the grid timestep and for each grid:
/           - copy the fields to the old fields
/           - solve the hydro equations (and save fluxes around subgrid)
/           - set the boundary values from parent and/or other grids
/           - update time and check dt(min) for that grid against dt(cycle)
/           - call EvolveLevel(level+1)
/           - accumulate flux around this grid
/       - correct the solution on this grid based on subgrid solutions
/       - correct the solution on this grid based on improved subgrid fluxes
/
/    This routine essentially solves (completely) the grids of this level
/       and all finer levels and then corrects the solution of
/       grids on this level based on the improved subgrid solutions/fluxes.
/
/    Note: as a convenience, we store the current grid's fluxes (i.e. the
/          fluxes around the exterior of this grid) as the last entry in
/          the list of subgrids.
/
************************************************************************/

#ifdef RAD_HYDRO
#include "ImplicitProblemABC_preincludes.h"
#endif
 
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <math.h>

#ifdef USE_MPI
#include <mpi.h>
#endif /* USE_MPI */

#ifdef USE_PAT
#include <pat_api.h>
#endif /* USE_PAT */
 
#include "performance.h"
#include "macros_and_parameters.h"
#include "typedefs.h"
#include "global_data.h"
#include "Fluxes.h"
#include "GridList.h"
#include "ExternalBoundary.h"
#include "Grid.h"
#include "Hierarchy.h"
#include "TopGridData.h"
#include "LevelHierarchy.h"
#ifdef RAD_HYDRO
#include "ImplicitProblemABC.h"
#endif 
 
/* function prototypes */
 
void DeleteFluxes(fluxes *Fluxes);
int  RebuildHierarchy(TopGridData *MetaData,
		      LevelHierarchyEntry *LevelArray[], int level);
int  ReportMemoryUsage(char *header = NULL);
int  UpdateParticlePositions(grid *Grid);
int  CheckEnergyConservation(HierarchyEntry *Grids[], int grid,
			     int NumberOfGrids, int level, float dt);
float CommunicationMinValue(float Value);
int GenerateGridArray(LevelHierarchyEntry *LevelArray[], int level,
		      HierarchyEntry **Grids[]);
 
#ifdef SIB3
int PrepareDensityField(LevelHierarchyEntry *LevelArray[],
			SiblingGridList SiblingList[],
			int level, TopGridData *MetaData, FLOAT When);
#else  // !SIB3
int PrepareDensityField(LevelHierarchyEntry *LevelArray[],
                        int level, TopGridData *MetaData, FLOAT When);
#endif  // end SIB3
 
#ifdef SIB2
int SetBoundaryConditions(HierarchyEntry *Grids[], int NumberOfGrids,
			  SiblingGridList SiblingList[],
			  int level, TopGridData *MetaData,
			  ExternalBoundary *Exterior, LevelHierarchyEntry * Level);
#else
int SetBoundaryConditions(HierarchyEntry *Grids[], int NumberOfGrids,
                          int level, TopGridData *MetaData,
                          ExternalBoundary *Exterior, LevelHierarchyEntry * Level);
#endif

#ifdef SAB
#ifdef SIB2
int SetAccelerationBoundary(HierarchyEntry *Grids[], int NumberOfGrids,
			    SiblingGridList SiblingList[],
			    int level, TopGridData *MetaData,
			    ExternalBoundary *Exterior,
			    LevelHierarchyEntry * Level,
			    int CycleNumber);
#else
int SetAccelerationBoundary(HierarchyEntry *Grids[], int NumberOfGrids,
			    int level, TopGridData *MetaData, 
			    ExternalBoundary *Exterior,
			    LevelHierarchyEntry * Level,
			    int CycleNumber);
#endif
#endif

#ifdef FLUX_FIX
int UpdateFromFinerGrids(int level, HierarchyEntry *Grids[], int NumberOfGrids,
			 int NumberOfSubgrids[],
			 fluxes **SubgridFluxesEstimate[],
			 LevelHierarchyEntry *SUBlingList[],
			 TopGridData *MetaData);
#else
int UpdateFromFinerGrids(int level, HierarchyEntry *Grids[], int NumberOfGrids,
			 int NumberOfSubgrids[],
			 fluxes **SubgridFluxesEstimate[]);
#endif
 
int CommunicationUpdateStarParticleCount(HierarchyEntry *Grids[],
					 TopGridData *MetaData,
					 int NumberOfGrids);
int RadiationFieldUpdate(LevelHierarchyEntry *LevelArray[], int level,
			 TopGridData *MetaData);
int WriteStreamData(HierarchyEntry *Grids[], int NumberOfGrids, 
		    TopGridData *MetaData, int CycleCount, int EndStep = FALSE);
int WriteMovieData(char *basename, int filenumber,
		   LevelHierarchyEntry *LevelArray[], TopGridData *MetaData,
		   FLOAT WriteTime);
int WriteTracerParticleData(char *basename, int filenumber,
		   LevelHierarchyEntry *LevelArray[], TopGridData *MetaData,
		   FLOAT WriteTime);

#ifdef USE_HDF5_GROUPS
int Group_WriteAllData(char *basename, int filenumber, HierarchyEntry *TopGrid,
		       TopGridData &MetaData, ExternalBoundary *Exterior,
#ifdef RAD_HYDRO
		       ImplicitProblemABC *ImplicitSolver,
#endif
		       FLOAT WriteTime = -1);
#else
int WriteAllData(char *basename, int filenumber, HierarchyEntry *TopGrid,
		 TopGridData &MetaData, ExternalBoundary *Exterior,
#ifdef RAD_HYDRO
		 ImplicitProblemABC *ImplicitSolver,
#endif
		 FLOAT WriteTime = -1);
#endif
 
int ComputeRandomForcingNormalization(LevelHierarchyEntry *LevelArray[],
                                      int level, TopGridData *MetaData,
                                      float * norm, float * pTopGridTimeStep);

int FastSiblingLocatorInitializeStaticChainingMesh(ChainingMeshStructure *Mesh, int Rank,
						   int TopGridDims[]); 
int FastSiblingLocatorInitialize(ChainingMeshStructure *Mesh, int Rank,
				 int TopGridDims[]);
int FastSiblingLocatorFinalize(ChainingMeshStructure *Mesh);
 
#ifdef FLUX_FIX
int CreateSUBlingList(TopGridData *MetaData,
		      HierarchyEntry *Grids[],
		      int NumberOfGrids,
		      LevelHierarchyEntry ***SUBlingList);
int DeleteSUBlingList(int NumberOfGrids,
		      LevelHierarchyEntry **SUBlingList);
#endif

void my_exit(int status);

#ifdef MEM_TRACE
Eint64 mused(void);
#endif

 

 
static int LevelCycleCount[MAX_DEPTH_OF_HIERARCHY];
double LevelWallTime[MAX_DEPTH_OF_HIERARCHY];
double LevelZoneCycleCount[MAX_DEPTH_OF_HIERARCHY];
double LevelZoneCycleCountPerProc[MAX_DEPTH_OF_HIERARCHY];
 
static float norm = 0.0;            //AK
static float TopGridTimeStep = 0.0; //AK

static int StaticSiblingListInitialized = 0;

#ifdef STATIC_SIBLING_LIST
static SiblingGridList StaticSiblingList[MAX_NUMBER_OF_SUBGRIDS];
static int StaticLevelZero = 1;
#else
static int StaticLevelZero = 0;
#endif

 


int EvolveLevel(TopGridData *MetaData, LevelHierarchyEntry *LevelArray[],
		int level, float dtLevelAbove, ExternalBoundary *Exterior
#ifdef RAD_HYDRO
		, ImplicitProblemABC *ImplicitSolver
#endif
		)
{
  /* Declarations */

  int dbx = 0;
 
  FLOAT When;
  float dtThisLevelSoFar = 0.0, dtThisLevel, dtGrid, dtActual, dtLimit;
  int RefinementFactors[MAX_DIMENSION];
  int cycle = 0, counter = 0, grid1, subgrid, grid2;
  HierarchyEntry *NextGrid;

  double t_entry, t_exit, t_call, t_return, t_rebuild1, t_rebuild2, t_acc;

#ifdef MEM_TRACE
    Eint64 MemInUse;
#endif

#ifdef USE_PAT
  Eint32 level_tag;
  Eint32 pat_status;
  char *level_name;
  char *level_number;
  level_name = new char[MAX_LINE_LENGTH];
  level_number = new char[3];
  strcpy(level_name, "EvolveLevel_");
  sprintf(level_number, "%2.2"ISYM, level);
  strcat(level_name, level_number);
  level_tag = 10+level;
  // tag must be < 100

  pat_status = PAT_region_begin(level_tag, level_name);
  // PAT_record(PAT_STATE_ON);
#endif /* USE_PAT */
 
#if defined(USE_JBPERF) && defined(JB_PERF_LEVELS)
  Eint32 jb_level = level;
  jbPerf.attribute ("level",&jb_level,JB_INT);
#endif

#ifdef USE_MPI
  t_entry = MPI_Wtime();
  t_acc = 0.0;
#endif

#ifdef MEM_TRACE
    MemInUse = mused();
    fprintf(memtracePtr, "Enter EL Level %8"ISYM"  %16"ISYM" \n", level, MemInUse);
    fflush(memtracePtr);
#endif

  /* Create an array (Grids) of all the grids. */

  JBPERF_START("evolve-level-01"); // GenerateGridArray ()

  typedef HierarchyEntry* HierarchyEntryPointer;
  HierarchyEntry **Grids;

  int NumberOfGrids = GenerateGridArray(LevelArray, level, &Grids);
  int *NumberOfSubgrids = new int[NumberOfGrids];
  fluxes ***SubgridFluxesEstimate = new fluxes **[NumberOfGrids];

  JBPERF_STOP("evolve-level-01"); // GenerateGridArray ()

  JBPERF_START("evolve-level-02"); // SetBoundaryConditions()

#ifdef FLUX_FIX
  /* Create a SUBling list of the subgrids */
 
  LevelHierarchyEntry **SUBlingList;
#endif

  /* Initialize the chaining mesh used in the FastSiblingLocator. */

  if (dbx) fprintf(stderr, "EL: Initialize FSL \n"); 

  // If this is level 0 the SiblingList does not change and can be static

#ifdef STATIC_SIBLING_LIST
  if ( StaticLevelZero == 1 && level == 0 ) {

    if (!StaticSiblingListInitialized) {

      fprintf(stderr, "INITIALIZE Level 0 StaticSiblingList\n");

      ChainingMeshStructure StaticChainingMesh;

      FastSiblingLocatorInitializeStaticChainingMesh(&StaticChainingMesh, MetaData->TopGridRank,
						     MetaData->TopGridDims);

      for (grid1 = 0; grid1 < NumberOfGrids; grid1++)
        Grids[grid1]->GridData->FastSiblingLocatorAddGrid(&StaticChainingMesh);

      for (grid1 = 0; grid1 < NumberOfGrids; grid1++)
        if (Grids[grid1]->GridData->FastSiblingLocatorFindSiblings(
                              &StaticChainingMesh, &StaticSiblingList[grid1],
                              MetaData->LeftFaceBoundaryCondition,
                              MetaData->RightFaceBoundaryCondition) == FAIL) {
          fprintf(stderr, "Error in grid->FastSiblingLocatorFindSiblings.\n");
          return FAIL;
        }

      /* Clean up the chaining mesh. */

      FastSiblingLocatorFinalize(&StaticChainingMesh);

      StaticSiblingListInitialized = 1;

    }

  } // if StaticLevelZero && level == 0
#endif

  SiblingGridList *SiblingList = new SiblingGridList[NumberOfGrids];

  ChainingMeshStructure ChainingMesh;

#ifdef STATIC_SIBLING_LIST
  if (StaticLevelZero == 1 && level == 0 ) {

    for (grid1 = 0; grid1 < NumberOfGrids; grid1++) {
      SiblingList[grid1].NumberOfSiblings = StaticSiblingList[grid1].NumberOfSiblings;
      SiblingList[grid1].GridList = StaticSiblingList[grid1].GridList;
    }

  }
#endif

  if (( StaticLevelZero == 1 && level != 0 ) || StaticLevelZero == 0 ) {

  FastSiblingLocatorInitialize(&ChainingMesh, MetaData->TopGridRank,
			       MetaData->TopGridDims);
 
  /* Add all the grids to the chaining mesh. */

  if (dbx) fprintf(stderr, "EL: FSL AddGrid entry \n");

  for (grid1 = 0; grid1 < NumberOfGrids; grid1++)
    Grids[grid1]->GridData->FastSiblingLocatorAddGrid(&ChainingMesh);

  if (dbx) fprintf(stderr, "EL: FSL AddGrid exit \n");
 
  /* For each grid, get a list of possible siblings from the chaining mesh. */
 
  for (grid1 = 0; grid1 < NumberOfGrids; grid1++)
    if (Grids[grid1]->GridData->FastSiblingLocatorFindSiblings(
                              &ChainingMesh, &SiblingList[grid1],
			      MetaData->LeftFaceBoundaryCondition,
			      MetaData->RightFaceBoundaryCondition) == FAIL) {
      fprintf(stderr, "Error in grid->FastSiblingLocatorFindSiblings.\n");
      return FAIL;
    }
 
  /* Clean up the chaining mesh. */
 
  FastSiblingLocatorFinalize(&ChainingMesh);

  }



#ifdef EMISSIVITY
/* reset Emissivity array here before next step calculate the new values */
  if (StarMakerEmissivityField > 0) {

  /*
     clear the Emissivity of the level below, after the level below
     updated the current level (it's parent) and before the next
     timestep at the current level.
  */
    LevelHierarchyEntry *Temp;
    Temp = LevelArray[level+1];

    while (Temp != NULL) {
      /*
      printf("=======at level %"ISYM" clearing level %"ISYM"=======\n",
	     level, level+1);
      */
      Temp->GridData->ClearEmissivity();
      Temp = Temp->NextGridThisLevel;
    }
  }
#endif




  /* ================================================================== */
  /* For each grid: a) interpolate boundaries from its parent.
                    b) copy any overlapping zones.  */
 
#ifdef SIB2
  if (SetBoundaryConditions(Grids, NumberOfGrids, SiblingList,
			    level, MetaData, Exterior, LevelArray[level]) == FAIL)
    return FAIL;
#else
  if (SetBoundaryConditions(Grids, NumberOfGrids, level, MetaData,
                            Exterior, LevelArray[level]) == FAIL)
    return FAIL;
#endif
 
  JBPERF_STOP("evolve-level-02"); // SetBoundaryConditions()

  /* Clear the boundary fluxes for all Grids (this will be accumulated over
     the subcycles below (i.e. during one current grid step) and used to by the
     current grid to correct the zones surrounding this subgrid (step #18). */
 
  JBPERF_START("evolve-level-03"); // ClearBoundaryFluxes()

  for (grid1 = 0; grid1 < NumberOfGrids; grid1++)
    Grids[grid1]->GridData->ClearBoundaryFluxes();
 
  JBPERF_STOP("evolve-level-03"); // ClearBoundaryFluxes()

  for (grid1 = 0; grid1 < NumberOfGrids; grid1++)
    Grids[grid1]->GridData->CountGridsOnLevel(level);

  /* ================================================================== */
  /* Loop over grid timesteps until the elapsed time equals the timestep
     from the level above (or loop once for the top level). */

  dtActual = 0.0; 

  while (dtThisLevelSoFar < dtLevelAbove) {
 
    /* Determine the timestep for this iteration of the loop. */
 
    JBPERF_START("evolve-level-04"); // SetTimeStep()

    if (level == 0) {
 
      /* For root level, use dtLevelAbove. */
 
      dtThisLevel      = dtLevelAbove;
      dtThisLevelSoFar = dtLevelAbove;
 
    } else {
 
      /* Compute the mininum timestep for all grids. */
 
      dtThisLevel = huge_number;
      for (grid1 = 0; grid1 < NumberOfGrids; grid1++) {
	dtGrid      = Grids[grid1]->GridData->ComputeTimeStep();
	dtThisLevel = min(dtThisLevel, dtGrid);
      }
      dtThisLevel = CommunicationMinValue(dtThisLevel);

      dtActual = dtThisLevel;

#ifdef USE_DT_LIMIT

//    dtLimit = LevelZeroDeltaT/(4.0)/POW(RefineBy,level);

      dtLimit = 0.5/(4.0)/POW(2.0,level);

      if ( dtActual < dtLimit ) {
        dtThisLevel = dtLimit;
      }

#endif
 
      /* Advance dtThisLevelSoFar (don't go over dtLevelAbove). */
 
      if (dtThisLevelSoFar+dtThisLevel*1.05 >= dtLevelAbove) {
	dtThisLevel      = dtLevelAbove - dtThisLevelSoFar;
	dtThisLevelSoFar = dtLevelAbove;
      }
      else
	dtThisLevelSoFar += dtThisLevel;
 
    }

    if (debug) printf("Level[%"ISYM"]: dt = %"GSYM"  %"GSYM"  (%"GSYM"/%"GSYM")\n", level, dtThisLevel, dtActual,
		      dtThisLevelSoFar, dtLevelAbove);
 
    /* Set all grid's timestep to this minimum dt. */
 
    for (grid1 = 0; grid1 < NumberOfGrids; grid1++)
      Grids[grid1]->GridData->SetTimeStep(dtThisLevel);
 
    JBPERF_STOP("evolve-level-04"); // SetTimeStep()

    /* For each grid, compute the number of it's subgrids. */
 
    JBPERF_START("evolve-level-05"); // compute number of subgrids

    for (grid1 = 0; grid1 < NumberOfGrids; grid1++) {
      NextGrid = Grids[grid1]->NextGridNextLevel;
      counter = 0;
      while (NextGrid != NULL) {
	NextGrid = NextGrid->NextGridThisLevel;
	if (++counter > MAX_NUMBER_OF_SUBGRIDS) {
	  fprintf(stderr, "More subgrids than MAX_NUMBER_OF_SUBGRIDS.\n");
	  return FAIL;
	}
      }
      NumberOfSubgrids[grid1] = counter + 1;
    }
 
    JBPERF_STOP("evolve-level-05"); // compute number of subgrids

    /* For each grid, create the subgrid list. */
 
    JBPERF_START("evolve-level-06"); // create subgrid list

    for (grid1 = 0; grid1 < NumberOfGrids; grid1++) {
 
      /* Allocate the subgrid fluxes for this grid. */
 
      SubgridFluxesEstimate[grid1] = new fluxes *[NumberOfSubgrids[grid1]];
 
      for (subgrid = 0; subgrid < NumberOfSubgrids[grid1]; subgrid++)
	SubgridFluxesEstimate[grid1][subgrid] = NULL;
 
      /* Collect the flux data and store it in the newly minted fluxes.
	 Or rather that's what we should do.  Instead, we create fluxes one
	 by one in this awkward array of pointers to pointers.  This should be
	 changed so that all the routines take arrays of flux rather than
	 arrays of pointers to flux.  Dumb. */
 
      counter = 0;

#ifdef JB_OPT_FAST_NEIGHBOR_SEARCH
      if (MyProcessorNumber ==
          Grids[grid1]->GridData->ReturnProcessorNumber()) {
#endif
 
	NextGrid = Grids[grid1]->NextGridNextLevel;
	while (NextGrid != NULL) {
	  SubgridFluxesEstimate[grid1][counter] = new fluxes;
	  Grids[grid1]->GridData->ComputeRefinementFactors
	                              (NextGrid->GridData, RefinementFactors);
	  NextGrid->GridData->ReturnFluxDims
             (*(SubgridFluxesEstimate[grid1][counter++]), RefinementFactors);
	  NextGrid = NextGrid->NextGridThisLevel;
	}
 
	/* Add the external boundary of this subgrid to the subgrid list. This
	   makes it easy to keep adding up the fluxes of this grid, but we must
	   keep in mind that the last subgrid should be ignored elsewhere. */
 
	SubgridFluxesEstimate[grid1][counter] = new fluxes;
	Grids[grid1]->GridData->ComputeRefinementFactors
                                   (Grids[grid1]->GridData, RefinementFactors);
	Grids[grid1]->GridData->ReturnFluxDims
               (*(SubgridFluxesEstimate[grid1][counter]), RefinementFactors);

#ifdef JB_OPT_FAST_NEIGHBOR_SEARCH
      }
#endif
 
    } // end loop over grids (create Subgrid list)
 
    JBPERF_STOP("evolve-level-06"); // create subgrid list

    /* ------------------------------------------------------- */
    /* Prepare the density field (including particle density). */
 
//  fprintf(stderr, "%"ISYM": EvolveLevel: Enter PrepareDensityField\n", MyProcessorNumber);
 
    JBPERF_START("evolve-level-07"); // PrepareDensityField()

    When = 0.5;

#ifdef RAD_HYDRO
    if (RadiationHydrodynamics < 2) {
#endif
 
#ifdef SIB3
    if (SelfGravity)
      if (PrepareDensityField(LevelArray, SiblingList,
			      level, MetaData, When) == FAIL) {
	fprintf(stderr, "Error in PrepareDensityField.\n");
	return FAIL;
      }
#else   // !SIB3
    if (SelfGravity)
      if (PrepareDensityField(LevelArray, level, MetaData, When) == FAIL) {
        fprintf(stderr, "Error in PrepareDensityField.\n");
        return FAIL;
      }
#endif  // end SIB3
 
 
//  fprintf(stderr, "%"ISYM": EvolveLevel: Exit PrepareDensityField\n", MyProcessorNumber);
 
    /* Prepare normalization for random forcing. Involves top grid only. */
 
    if (RandomForcing && MetaData->CycleNumber > 0 && level == 0)
      if ( ComputeRandomForcingNormalization(LevelArray, 0, MetaData,
                                             &norm, &TopGridTimeStep)
           == FAIL ) {
        fprintf(stderr, "Error in ComputeRandomForcingNormalization.\n");
        return FAIL;
      }

#ifdef RAD_HYDRO
    }
#endif
 
    JBPERF_STOP("evolve-level-07"); // PrepareDensityField()

    /* ------------------------------------------------------- */
    /* Evolve all grids by timestep dtThisLevel. */
 
    for (grid1 = 0; grid1 < NumberOfGrids; grid1++) {
 
      /* Call analysis routines. */
 
      JBPERF_START_LOW("evolve-level-08"); // Call analysis routines

      if (ProblemType == 24)
	Grids[grid1]->GridData->SphericalInfallGetProfile(level, 1);
      if (ProblemType == 30)
	Grids[grid1]->GridData->AnalyzeTrackPeaks(level, 0);
      if (ProblemType == 27)
	if (Grids[grid1]->GridData->ReturnProcessorNumber()==MyProcessorNumber){
	  float AM[3], MeanVelocity[3], DMVelocity[3];
	  FLOAT Center[] = {0,0,0}, CenterOfMass[3], DMCofM[3];
	  Grids[grid1]->GridData->CalculateAngularMomentum(Center, AM,
			   MeanVelocity, DMVelocity, CenterOfMass, DMCofM);
	  fprintf(stdout, "level = %"ISYM" %"ISYM" %"ISYM"  Vel %"FSYM" %"FSYM" %"FSYM"  DMVel %"FSYM" %"FSYM" %"FSYM"  CofM %"PSYM" %"PSYM" %"PSYM"  DMCofM %"FSYM" %"FSYM" %"FSYM"\n",
		level, LevelCycleCount[level], grid1, MeanVelocity[0],
		MeanVelocity[1], MeanVelocity[2],
		DMVelocity[0], DMVelocity[1], DMVelocity[2],
		-CenterOfMass[0], -CenterOfMass[1], -CenterOfMass[2],
		DMCofM[0], DMCofM[1], DMCofM[2]);
	}
 
      JBPERF_STOP_LOW("evolve-level-08"); // Call analysis routines

      /* Gravity: compute acceleration field for grid and particles. */

#ifdef RAD_HYDRO
    if (RadiationHydrodynamics < 2) {
#endif
 
      JBPERF_START("evolve-level-09"); // Compute self-gravity acceleration

      if (SelfGravity) {
	int Dummy;
	if (level <= MaximumGravityRefinementLevel) {
 
	  /* Compute the potential. */
 
	  if (level > 0)
	    if (Grids[grid1]->GridData->SolveForPotential(Dummy, level)
		== FAIL) {
	      fprintf(stderr, "Error in grid->SolveForPotential.\n");
	      return FAIL;
	    }
	  if (Grids[grid1]->GridData->ComputeAccelerations(level) == FAIL) {
	    fprintf(stderr, "Error in grid->ComputeAccelerations.\n");
	    return FAIL;
	  }
	}
	  /* otherwise, interpolate potential from coarser grid, which is
	     now done in PrepareDensity. */
 
      } // end: if (SelfGravity)
 
      JBPERF_STOP("evolve-level-09"); // Compute self-gravity acceleration

#ifdef RAD_HYDRO
    }
#endif

      /* Gravity: compute field due to preset sources. */
 
#ifdef RAD_HYDRO
    if (RadiationHydrodynamics < 2) {
#endif

      JBPERF_START_LOW("evolve-level-10"); // ComputeAccelerationFieldExternal()

      if (UniformGravity || PointSourceGravity)
	if (Grids[grid1]->GridData->ComputeAccelerationFieldExternal() ==FAIL) {
	  fprintf(stderr,"Error in grid->ComputeAccelerationFieldExternal.\n");
	  return FAIL;
	}
 
      JBPERF_STOP_LOW("evolve-level-10"); // ComputeAccelerationFieldExternal()

#ifdef RAD_HYDRO
    }
#endif

      /* Check for energy conservation. */
/*
      if (ComputePotential)
	if (CheckEnergyConservation(Grids, grid, NumberOfGrids, level,
				    dtThisLevel) == FAIL) {
	  fprintf(stderr, "Error in CheckEnergyConservation.\n");
	  return FAIL;
	}
*/

    } // End of loop over grids

    //This ensures that all subgrids agree in the boundary.
    //Not a big deal for hydro, but essential for DivB = 0 in MHD runs.
    //Only called on level > 0 because the root grid is dealt with differently than SG's.

#ifdef RAD_HYDRO
    if (RadiationHydrodynamics < 2) {
#endif

#ifdef SAB
    if ( (SelfGravity || UniformGravity || PointSourceGravity) && level > 0) {
#ifdef SIB2
      if( SetAccelerationBoundary(Grids, NumberOfGrids,
				  SiblingList,
				  level, MetaData,
				  Exterior, LevelArray[level], LevelCycleCount[level]) == FAIL ) {
	fprintf(stderr,"Error with AccelerationBoundary.\n");
	return FAIL;
      }
#else
      if( SetAccelerationBoundary(Grids, NumberOfGrids,
				  level, MetaData,
				  Exterior, LevelArray[level], LevelCycleCount[level]) == FAIL ) {
	fprintf(stderr,"Error with AccelerationBoundary.\n");
	return FAIL;
      }
#endif
    }
#endif

#ifdef RAD_HYDRO
    }
#endif

    for (grid1 = 0; grid1 < NumberOfGrids; grid1++) {

      /* Copy current fields (with their boundaries) to the old fields
	  in preparation for the new step. */
 
      JBPERF_START("evolve-level-11"); // CopyBaryonFieldToOldBaryonField()

	if (Grids[grid1]->GridData->CopyBaryonFieldToOldBaryonField() == FAIL) {
	  fprintf(stderr, "Error in grid->CopyBaryonFieldToOldBaryonField.\n");
	  return FAIL;
	}
 
      JBPERF_STOP("evolve-level-11"); // CopyBaryonFieldToOldBaryonField()

      /* Add RandomForcing fields to velocities after the copying of current
         fields to old. I also update the total energy accordingly here.
         It makes no sense to force on the very first time step. */

#ifdef RAD_HYDRO
    if (RadiationHydrodynamics < 2) {
#endif
 
      JBPERF_START_LOW("evolve-level-12"); // AddRandomForcing()

      if (RandomForcing && MetaData->CycleNumber > 0) //AK
        if(Grids[grid1]->GridData->AddRandomForcing(&norm,
                                                   TopGridTimeStep) == FAIL)
          fprintf(stderr, "Error in AddRandomForcing.\n");
 
      JBPERF_STOP_LOW("evolve-level-12"); // AddRandomForcing()

#ifdef RAD_HYDRO
    }
#endif


      /* Call hydro solver and save fluxes around subgrids. */

#ifdef RAD_HYDRO
    if (RadiationHydrodynamics < 2) {
#endif
 
      JBPERF_START("evolve-level-13"); // SolveHydroEquations()

//      fprintf(stderr, "%"ISYM": Calling Hydro\n", MyProcessorNumber);
 
      if (Grids[grid1]->GridData->SolveHydroEquations(LevelCycleCount[level],
	 NumberOfSubgrids[grid1], SubgridFluxesEstimate[grid1], level) == FAIL) {
	fprintf(stderr, "Error in grid->SolveHydroEquations.\n");
	return FAIL;
      }
 
      JBPERF_STOP("evolve-level-13"); // SolveHydroEquations()

#ifdef RAD_HYDRO
    }
#endif


//      fprintf(stderr, "%"ISYM": Called Hydro\n", MyProcessorNumber);



#ifdef RAD_HYDRO
    if ((RadiationHydrodynamics == 0) || (level > 0) || (RadiativeTransfer > 0)) {
#endif


//-----------------------------------------------------------------------------------------
#ifdef RATE_AND_COOL

      /* Solve the cooling and species rate equations. */
 
//      fprintf(stderr, "%"ISYM": Calling SolveCoolAndRateEquations\n", MyProcessorNumber);

      if (MultiSpecies && RadiativeCooling) {
 
	JBPERF_START("evolve-level-14"); // change this?

	if (Grids[grid1]->GridData->SolveRateAndCoolEquations() == FAIL) {
	  fprintf(stderr, "Error in grid->SolveRateEquations.\n");
	  return FAIL;
	}
 
	JBPERF_STOP("evolve-level-14"); // change this?

//      fprintf(stderr, "%"ISYM": Called SolveCoolAndRateEquations\n", MyProcessorNumber);

      } else {
#endif

//-----------------------------------------------------------------------------------------

//      fprintf(stderr, "%"ISYM": Calling MultiSpecies\n", MyProcessorNumber);
 
	JBPERF_START("evolve-level-14"); // SolveRateEquations()

	if (MultiSpecies)
	  if (Grids[grid1]->GridData->SolveRateEquations() == FAIL) {
	    fprintf(stderr, "Error in grid->SolveRateEquations.\n");
	    return FAIL;
	  }
 
	JBPERF_STOP("evolve-level-14"); // SolveRateEquations()

//      fprintf(stderr, "%"ISYM": Called MultiSpecies\n", MyProcessorNumber);
 
	/* Include radiative cooling/heating. */
 
//      fprintf(stderr, "%"ISYM": Calling RadiativeCooling\n", MyProcessorNumber);
 
	JBPERF_START("evolve-level-15"); // SolveRadiativeCooling()

	if (RadiativeCooling)
	  if (Grids[grid1]->GridData->SolveRadiativeCooling() == FAIL) {
	    fprintf(stderr, "Error in grid->SolveRadiativeCooling.\n");
	    return FAIL;
	  }
 
	JBPERF_STOP("evolve-level-15"); // SolveRadiativeCooling()

//      fprintf(stderr, "%"ISYM": Called RadiativeCooling\n", MyProcessorNumber);

#ifdef RATE_AND_COOL
      }
#endif

//-----------------------------------------------------------------------------------------

#ifdef RAD_HYDRO
      }  /* end if (RadiationHydrodynamics == 0 || level > 0 || RadiativeTransfer > 0) */
#endif
 
      /* Update particle positions (if present). */
 
//      fprintf(stderr, "%"ISYM": Calling UpdatePP\n", MyProcessorNumber);

#ifdef RAD_HYDRO
      if (RadiationHydrodynamics < 2) {
#endif
 
      JBPERF_START("evolve-level-16"); // UpdateParticlePositions()

      if (UpdateParticlePositions(Grids[grid1]->GridData) == FAIL) {
	fprintf(stderr, "Error in UpdateParticlePositions.\n");
	return FAIL;
      }
 
      JBPERF_STOP("evolve-level-16"); // UpdateParticlePositions()

#ifdef RAD_HYDRO
      }
#endif

//      fprintf(stderr, "%"ISYM": Called UpdatePP\n", MyProcessorNumber);
 
      /* Include 'star' particle creation and feedback.
         (first, set the under_subgrid field). */

#ifdef RAD_HYDRO
      if (RadiationHydrodynamics < 2) {
#endif
 
      JBPERF_START_LOW("evolve-level-17"); // star particle creation/feedback

      if (StarParticleCreation || StarParticleFeedback) {
	Grids[grid1]->GridData->ZeroSolutionUnderSubgrid(NULL,
						 ZERO_UNDER_SUBGRID_FIELD);
	LevelHierarchyEntry *Temp2 = LevelArray[level+1];
	while (Temp2 != NULL) {
	  Grids[grid1]->GridData->ZeroSolutionUnderSubgrid(Temp2->GridData,
					 ZERO_UNDER_SUBGRID_FIELD);
	  Temp2 = Temp2->NextGridThisLevel;
	}
      }

      if (StarParticleCreation || StarParticleFeedback) {
	if (Grids[grid1]->GridData->StarParticleHandler(level
#ifdef EMISSIVITY
							, dtLevelAbove
#endif
							) == FAIL) {
	  fprintf(stderr, "Error in grid->StarParticleWrapper");
	  return FAIL;
	}
      }
 
      JBPERF_STOP_LOW("evolve-level-17"); // star particle creation/feedback

#ifdef RAD_HYDRO
      }
#endif



      /* Coupled Rad-Hydro solver. */

#ifdef RAD_HYDRO
      if ((RadiationHydrodynamics > 0) && (level == 0))  {
	JBPERF_START("evolve-level-17.5"); // ImplicitSolver->Evolve()

// ifdef MEM_TRACE
//     MemInUse = mused();
//     fprintf(memtracePtr, "Enter RHD %8"ISYM" \n", MemInUse);
//     fflush(memtracePtr);
// endif

	if (ImplicitSolver->Evolve(Grids[grid1],
				   Grids[grid1]->GridData->ReturnTimeStep()
				   ) == FAIL) {
	  fprintf(stderr, "Error in ImplicitSolver->Evolve.\n");
	  return FAIL;
	}

// ifdef MEM_TRACE
//     MemInUse = mused();
//     fprintf(memtracePtr, "Exit  RHD %8"ISYM" \n", MemInUse);
//     fflush(memtracePtr);
// endif

	JBPERF_STOP("evolve-level-17.5"); // ImplicitSolver->Evolve()
      }
#endif


      /* Gravity: clean up AccelerationField. */

#ifdef RAD_HYDRO
      if (RadiationHydrodynamics < 2) {
#endif

      JBPERF_START_LOW("evolve-level-18"); // clean up AccelerationField

      // David Collins removes this for MHD Amr
      if (SelfGravity || UniformGravity || PointSourceGravity) {
	if (level != MaximumGravityRefinementLevel ||
	    MaximumGravityRefinementLevel == MaximumRefinementLevel)
	  Grids[grid1]->GridData->DeleteAccelerationField();
	Grids[grid1]->GridData->DeleteParticleAcceleration();
      }
 
      JBPERF_STOP_LOW("evolve-level-18"); // clean up AccelerationField

#ifdef RAD_HYDRO
      }
#endif

      /* Update current problem time of this subgrid. */
 
      JBPERF_START_LOW("evolve-level-19"); // SetTimeNextTimestep()

      Grids[grid1]->GridData->SetTimeNextTimestep();
 
      JBPERF_STOP_LOW("evolve-level-19"); // SetTimeNextTimestep()

      /* If using comoving co-ordinates, do the expansion terms now. */
 
      JBPERF_START("evolve-level-20"); // ComovingExpansionTerms()

      if (ComovingCoordinates)
	Grids[grid1]->GridData->ComovingExpansionTerms();
 
      JBPERF_STOP("evolve-level-20"); // ComovingExpansionTerms()

    }  // end loop over grids
 
    /* For each grid: a) interpolate boundaries from the parent grid.
                      b) copy any overlapping zones from siblings. */
 
    JBPERF_START("evolve-level-21"); // SetBoundaryConditions()

#ifdef SIB2
    if (SetBoundaryConditions(Grids, NumberOfGrids, SiblingList,
			      level, MetaData, Exterior, LevelArray[level]) == FAIL)
      return FAIL;
#else
    if (SetBoundaryConditions(Grids, NumberOfGrids, level, MetaData,
                              Exterior, LevelArray[level]) == FAIL)
      return FAIL;
#endif

    JBPERF_STOP("evolve-level-21"); // SetBoundaryConditions()

    /* Update the star particle counters. */
 
    JBPERF_START("evolve-level-22"); // CommunicationUpdateStarParticleCount()

    if (StarParticleCreation)
      if (CommunicationUpdateStarParticleCount(Grids, MetaData,
					       NumberOfGrids) == FAIL)
	return FAIL;
 
    JBPERF_STOP("evolve-level-22"); // CommunicationUpdateStarParticleCount()

    /* Check for movie output (only check if this is bottom of hierarchy). */
 
    JBPERF_START("evolve-level-23"); // WriteMovieData()

    if (LevelArray[level+1] == NULL)
      if (LevelArray[level]->GridData->ReturnTime() >=
	  MetaData->TimeLastMovieDump + MetaData->dtMovieDump &&
	  MetaData->dtMovieDump > 0.0) {
	MetaData->TimeLastMovieDump += MetaData->dtMovieDump;
	if (WriteMovieData(MetaData->MovieDumpName,
			  MetaData->MovieDumpNumber++, LevelArray, MetaData,
			  LevelArray[level]->GridData->ReturnTime()) == FAIL) {
	  fprintf(stderr, "Error in WriteMovieData.\n");
	  return FAIL;
	}
      }
 
    JBPERF_STOP("evolve-level-23"); // WriteMovieData()

    /* Check for tracer particle output (only if this bottom of hierarchy). */
 
    JBPERF_START("evolve-level-24"); // WriteTracerParticleData()

    if (LevelArray[level+1] == NULL)
      if (LevelArray[level]->GridData->ReturnTime() >=
	  MetaData->TimeLastTracerParticleDump +
	  MetaData->dtTracerParticleDump &&
	  MetaData->dtTracerParticleDump > 0.0) {
	MetaData->TimeLastTracerParticleDump += MetaData->dtTracerParticleDump;
	if (WriteTracerParticleData(MetaData->TracerParticleDumpName,
				    MetaData->TracerParticleDumpNumber++,
				    LevelArray, MetaData,
			  LevelArray[level]->GridData->ReturnTime()) == FAIL) {
	  fprintf(stderr, "Error in WriteTracerParticleData.\n");
	  return FAIL;
	}
      }
 
    JBPERF_STOP("evolve-level-24"); // WriteTracerParticleData()

    /* If cosmology, then compute grav. potential for output if needed. */

#ifdef RAD_HYDRO
    if (RadiationHydrodynamics < 2) {
#endif
 
    JBPERF_START("evolve-level-25"); // PrepareDensityField()

    if (ComovingCoordinates && SelfGravity && WritePotential) {
      CopyGravPotential = TRUE;
      When = 0.0;
 
#ifdef SIB3
      if (PrepareDensityField(LevelArray, SiblingList, level, MetaData, When) == FAIL) {
        fprintf(stderr, "Error in PrepareDensityField.\n");
        return FAIL;
      }
#else   // !SIB3
      if (PrepareDensityField(LevelArray, level, MetaData, When) == FAIL) {
        fprintf(stderr, "Error in PrepareDensityField.\n");
        return FAIL;
      }
#endif  // end SIB3
 
      CopyGravPotential = FALSE;
 
      for (grid1 = 0; grid1 < NumberOfGrids; grid1++) {
        int Dummy;
        if (level <= MaximumGravityRefinementLevel) {
 
          /* Compute the potential. */
 
          if (level > 0)
            if (Grids[grid1]->GridData->SolveForPotential(Dummy, level)
                == FAIL) {
              fprintf(stderr, "Error in grid->SolveForPotential.\n");
              return FAIL;
            }
          // fprintf(stderr, "Call CP from EvolveLevel\n");
          Grids[grid1]->GridData->CopyPotentialToBaryonField();
        }
        /* otherwise output empty potential field. */
 
      } //  end loop over grids
    } // if WritePotential
 
    JBPERF_STOP("evolve-level-25"); // PrepareDensityField()

#ifdef RAD_HYDRO
    }
#endif

    /* Check for new level output (only if this is bottom of hierarchy). */
 
    JBPERF_START("evolve-level-26"); // WriteAllData()

    if (MetaData->OutputFirstTimeAtLevel > 0 &&
	level >= MetaData->OutputFirstTimeAtLevel &&
	LevelArray[level+1] == NULL) {

      MetaData->OutputFirstTimeAtLevel = level+1;
      LevelHierarchyEntry *Temp2 = LevelArray[0];

      while (Temp2->NextGridThisLevel != NULL)
	Temp2 = Temp2->NextGridThisLevel; /* ugh: find last in linked list */

#ifdef USE_HDF5_GROUPS
      if (Group_WriteAllData(MetaData->DataDumpName, MetaData->DataDumpNumber++,
		       Temp2->GridHierarchyEntry, *MetaData, Exterior,
#ifdef RAD_HYDRO
		       ImplicitSolver,
#endif
		       LevelArray[level]->GridData->ReturnTime()) == FAIL) {
	fprintf(stderr, "Error in Group_WriteAllData.\n");
	return FAIL;
      }
#else
      if (WriteAllData(MetaData->DataDumpName, MetaData->DataDumpNumber++,
		       Temp2->GridHierarchyEntry, *MetaData, Exterior, 
#ifdef RAD_HYDRO
		       ImplicitSolver,
#endif
		       LevelArray[level]->GridData->ReturnTime()) == FAIL) {
	fprintf(stderr, "Error in WriteAllData.\n");
	return FAIL;
      }
#endif

    }

//--------------------------------------------------------------------------
// TURK1
//--------------------------------------------------------------------------

    JBPERF_STOP("evolve-level-26"); // WriteAllData()

    /* Check for stop (unpleasant to exit from here, but...). */
 
    if (MetaData->StopFirstTimeAtLevel > 0 &&
	level >= MetaData->StopFirstTimeAtLevel &&
	LevelArray[level+1] == NULL) {

      // Write movie data in all grids if necessary

      if (MovieSkipTimestep != INT_UNDEFINED)
	for (int mlevel = 0; mlevel < MAX_DEPTH_OF_HIERARCHY; mlevel++) {
	  if (LevelArray[mlevel] == NULL) break;
	  delete [] Grids;
	  NumberOfGrids = GenerateGridArray(LevelArray, mlevel, &Grids);
	  if (WriteStreamData(Grids, NumberOfGrids, MetaData,
			      LevelCycleCount[mlevel], TRUE) == FAIL) {
	    fprintf(stderr, "Error in WriteStreamData.\n");
	    return FAIL;
	  }
	}

      fprintf(stderr, "Stopping due to request on level %"ISYM"\n", level);
      my_exit(EXIT_SUCCESS);
    }
 
    /* For each grid, delete the GravitatingMassFieldParticles. */

#ifdef RAD_HYDRO
    if (RadiationHydrodynamics < 2) {
#endif
 
    JBPERF_START("evolve-level-27"); // DeleteGravitatingMassFieldParticles()

    for (grid1 = 0; grid1 < NumberOfGrids; grid1++)
      Grids[grid1]->GridData->DeleteGravitatingMassFieldParticles();
 
    JBPERF_STOP("evolve-level-27"); // DeleteGravitatingMassFieldParticles()

#ifdef RAD_HYDRO
    }
#endif

//--------------------------------------------------------------------------
// TURK2
//--------------------------------------------------------------------------

    /* ----------------------------------------- */
    /* Evolve the next level down (recursively). */
 
    if (dbx) fprintf(stderr, "EL Level %"ISYM" going to Level %"ISYM"\n", level, level+1);

#ifdef MEM_TRACE
    MemInUse = mused();
    fprintf(memtracePtr, "  EL Level %"ISYM" to Level %"ISYM" %16"ISYM" \n", level, level+1, MemInUse);
    fflush(memtracePtr);
#endif

#ifdef USE_MPI
  t_call = MPI_Wtime();
#endif

    if (LevelArray[level+1] != NULL) {
      if (EvolveLevel(MetaData, LevelArray, level+1, dtThisLevel, Exterior
#ifdef RAD_HYDRO
		      , ImplicitSolver
#endif
		      ) == FAIL) {
	fprintf(stderr, "Error in EvolveLevel (%"ISYM").\n", level);
	return FAIL;
      }
    }

#ifdef USE_MPI
  t_return = MPI_Wtime();
#endif

#ifdef MEM_TRACE
    MemInUse = mused();
    fprintf(memtracePtr, "  EL Level %"ISYM" from Level %"ISYM" %16"ISYM" \n", level, level+1, MemInUse);
    fflush(memtracePtr);
#endif

#if defined(USE_JBPERF) && defined(JB_PERF_LEVELS)
    jbPerf.attribute ("level",&jb_level,JB_INT);
#endif

    // Streaming movie output (only run if everything is evolved)

    if (MovieSkipTimestep != INT_UNDEFINED) {
      if (WriteStreamData(Grids, NumberOfGrids, MetaData, 
			  LevelCycleCount[level]) == FAIL) {
	fprintf(stderr, "Error in WriteStreamData.\n");
	return FAIL;
      }
    }

    if (dbx) fprintf(stderr, "EL Level %"ISYM" returns from Level %"ISYM"\n", level, level+1);

    /* ------------------------------------------------------- */
    /* For each grid,
     * (a) project the subgrid's solution into this grid (step #18)
     * (b) correct for the difference between this grid's fluxes and the
     *     subgrid's fluxes. (step #19)
     */
 
    JBPERF_START("evolve-level-28"); // UpdateFromFinerGrids()

#ifdef FLUX_FIX

    SUBlingList = new LevelHierarchyEntry*[NumberOfGrids];
    for(int list=0; list < NumberOfGrids; list++)
      SUBlingList[list] = NULL;

 
    if (FluxCorrection) {

      /* Fill in the SUBling list */

      if (dbx) fprintf(stderr, "EL: CSL entry \n");
      if (CreateSUBlingList(MetaData, Grids,
                              NumberOfGrids, &SUBlingList) == FAIL) {
        fprintf(stderr, "Error in CreateSUBlingList.\n");
        return FAIL;
      }
      if (dbx) fprintf(stderr, "EL: CSL exit \n");
    }

/* 
    LevelHierarchyEntry *NextMonkey;
 
    for(grid1 = 0; grid1 < NumberOfGrids; grid1++){
      NextMonkey = SUBlingList[grid1];
      while (NextMonkey != NULL) {
        // fprintf(stderr, "SGcheckEL%"ISYM": SUBling[%"ISYM"]->Grid pointer %p\n",
        //         MyProcessorNumber, grid1, NextMonkey->GridData);
        NextMonkey=NextMonkey->NextGridThisLevel;
      }
    }
*/

#endif
 
#ifdef FLUX_FIX
    if (UpdateFromFinerGrids(level, Grids, NumberOfGrids, NumberOfSubgrids,
			     SubgridFluxesEstimate,
			     SUBlingList,
			     MetaData) == FAIL)
      return FAIL;
#else
    if (UpdateFromFinerGrids(level, Grids, NumberOfGrids, NumberOfSubgrids,
			     SubgridFluxesEstimate) == FAIL)
      return FAIL;
#endif

    JBPERF_STOP("evolve-level-28"); // UpdateFromFinerGrids()

    if (dbx) fprintf(stderr, "OK after UpdateFromFinerGrids \n");

#ifdef FLUX_FIX
    if ( FluxCorrection ) {
      /* Clean up SUBlings */
      if (DeleteSUBlingList( NumberOfGrids, SUBlingList ) == FAIL) {
        fprintf(stderr, "Error in DeleteSUBlingList.\n");
        return FAIL;
      }
    }
#endif

    if (dbx) fprintf(stderr, "OK after DeleteSUBlingList \n");
 
    /* ------------------------------------------------------- */
    /* Add the saved fluxes (in the last subsubgrid entry) to the exterior
       fluxes for this subgrid .
       (Note: this must be done after CorrectForRefinedFluxes). */

#ifdef RAD_HYDRO
    if (RadiationHydrodynamics < 2) {
#endif
 
    JBPERF_START("evolve-level-29"); // AddToBoundaryFluxes()

    for (grid1 = 0; grid1 < NumberOfGrids; grid1++) {

#ifdef JB_OPT_FAST_NEIGHBOR_SEARCH
      if (MyProcessorNumber ==
          Grids[grid1]->GridData->ReturnProcessorNumber()) {
#endif
 
      if (FluxCorrection)
	if (Grids[grid1]->GridData->AddToBoundaryFluxes
	    (SubgridFluxesEstimate[grid1][NumberOfSubgrids[grid1] - 1])
	    == FAIL) {
	  fprintf(stderr, "Error in grid->AddToBoundaryFluxes.\n");
	  return FAIL;
	}
 
      /* Delete fluxes pointed to by SubgridFluxesEstimate[subgrid]. */
 
      for (subgrid = 0; subgrid < NumberOfSubgrids[grid1]; subgrid++) {
	DeleteFluxes(SubgridFluxesEstimate[grid1][subgrid]);
	delete       SubgridFluxesEstimate[grid1][subgrid];
      }
      delete [] SubgridFluxesEstimate[grid1];

#ifdef JB_OPT_FAST_NEIGHBOR_SEARCH
      }
#endif
 
    } // end of loop over grids
 
    JBPERF_STOP("evolve-level-29"); // AddToBoundaryFluxes()

#ifdef RAD_HYDRO
    }
#endif

    /* Recompute radiation field, if requested. */

#ifdef RAD_HYDRO
    if (RadiationHydrodynamics == 0) {
#endif
 
    JBPERF_START("evolve-level-30"); // RadiationFieldUpdate()

    if (RadiationFieldType >= 10 && RadiationFieldType <= 11 &&
	level <= RadiationFieldLevelRecompute)
      if (RadiationFieldUpdate(LevelArray, level, MetaData) == FAIL) {
	fprintf(stderr, "Error in RecomputeRadiationField.\n");
	return FAIL;
      }
 
    JBPERF_STOP("evolve-level-30"); // RadiationFieldUpdate()

#ifdef RAD_HYDRO
    }
#endif

    /* Rebuild the Grids on the next level down.
       Don't bother on the last cycle, as we'll rebuild this grid soon. */
 
    JBPERF_START("evolve-level-31"); // RebuildHierarchy()

#ifdef MEM_TRACE
    MemInUse = mused();
    fprintf(memtracePtr, "EL rebuild on level %8"ISYM"  %16"ISYM" \n", level, MemInUse);
    fflush(memtracePtr);
#endif

    t_rebuild1 = MPI_Wtime();
    if (dtThisLevelSoFar < dtLevelAbove) {
      if (RebuildHierarchy(MetaData, LevelArray, level) == FAIL) {
	fprintf(stderr, "Error in RebuildHierarchy.\n");
	return FAIL;
      }
    }
    t_rebuild2 = MPI_Wtime();

    t_acc += max((t_rebuild2 - t_rebuild1), 0.0);

#ifdef MEM_TRACE
    MemInUse = mused();
    fprintf(memtracePtr, "EL rebuild on level %8"ISYM"  %16"ISYM" \n", level, MemInUse);
    fflush(memtracePtr);
#endif
 
    /* Count up number of grids on this level. */
 
    int GridMemory, NumberOfCells, CellsTotal, Particles;
    float AxialRatio, GridVolume;
    for (grid1 = 0; grid1 < NumberOfGrids; grid1++) {
      Grids[grid1]->GridData->CollectGridInformation
        (GridMemory, GridVolume, NumberOfCells, AxialRatio, CellsTotal, Particles);
      LevelZoneCycleCount[level] += NumberOfCells;
      if (MyProcessorNumber == Grids[grid1]->GridData->ReturnProcessorNumber())
	LevelZoneCycleCountPerProc[level] += NumberOfCells;
    }
 
    JBPERF_STOP("evolve-level-31"); // RebuildHierarchy()

    cycle++;
    LevelCycleCount[level]++;
 
  } // end of loop over subcycles
 
  if (debug)
    fprintf(stderr, "EvolveLevel[%"ISYM"]: NumberOfSubCycles = %"ISYM" (%"ISYM" total)\n", level,
           cycle, LevelCycleCount[level]);
 
  /* If possible & desired, report on memory usage. */
 
  //  if (debug)
  ReportMemoryUsage("Memory usage report: Evolve Level");
 
#if defined(USE_JBPERF) && defined(JB_PERF_LEVELS)
  jbPerf.attribute ("level",0,JB_NULL);
#endif

  /* Clean up. */
 
#ifdef UNUSED
  if (level > MaximumGravityRefinementLevel &&
      level == MaximumRefinementLevel)
    ZEUSQuadraticArtificialViscosity /= 1;
#endif
 
  delete [] NumberOfSubgrids;
  delete [] Grids;
  delete [] SubgridFluxesEstimate;
 
  /* Clean up the sibling list. */

  if (( StaticLevelZero == 1 && level != 0 ) || StaticLevelZero == 0 ) {
  for (grid1 = 0; grid1 < NumberOfGrids; grid1++)
    delete [] SiblingList[grid1].GridList;
  delete [] SiblingList;
  }

  if (dbx) fprintf(stderr, "Return from EL Level %"ISYM"\n", level);

#ifdef MEM_TRACE
    MemInUse = mused();
    fprintf(memtracePtr, "Exit EL level %8"ISYM"  %16"ISYM" \n", level, MemInUse);
    fflush(memtracePtr);
#endif

#ifdef USE_MPI
  t_exit = MPI_Wtime();
#endif

  rebuild_timer[level] += t_acc;
  level_timer[level] += (max((t_exit-t_entry), 0.0) - max((t_return-t_call), 0.0));

#ifdef USE_PAT
  // PAT_record(PAT_STATE_OFF);
  pat_status = PAT_region_end(level_tag);
#endif /* USE_PAT */

  return SUCCESS;
 
}
