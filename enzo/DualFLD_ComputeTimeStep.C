/*****************************************************************************
 * Copyright 2013 Daniel R. Reynolds                                         *
 *                                                                           *
 * This software is released under the terms of the "Enzo Public License"    *
 * in the accompanying LICENSE file.                                         *
 *****************************************************************************/
/***********************************************************************
   Two-Group (X-ray + UV) Flux-Limited Diffusion Implicit Problem Class
   Time Step Computation Routine

   author: Daniel R. Reynolds
   date:   January 2013

   PURPOSE: Computes the rad-hydro time step size.  We note that this 
            value affects the global hydrodynamics time step: 
                  dt = min(dt_hydro,dt_radiation).
            This routine is called with scaled arguments.
 
            Also, the argument 'flag' determines which entries we use to 
            compute the time step:
                 0 -> use Xray radiation only
                 1 -> use UV radiation only
                 2 -> use both
************************************************************************/
#ifdef RAD_HYDRO
#include "DualFLD.h"


float DualFLD::ComputeTimeStep(EnzoVector *uold, EnzoVector *unew, int flag) {

  // get local mesh description
  int Nx, Ny, Nz, Nvar, ghXl, ghXr, ghYl, ghYr, ghZl, ghZr;
  unew->size(&Nx, &Ny, &Nz, &Nvar, &ghXl, &ghXr, &ghYl, &ghYr, &ghZl, &ghZr);
  if (Nx != LocDims[0]) {
    fprintf(stderr,"ComputeTimeStep error: x0 vector dims do not match\n");
    return FAIL;
  }
  if (Ny != LocDims[1]) {
    fprintf(stderr,"ComputeTimeStep error: x1 vector dims do not match\n");
    return FAIL;
  }
  if (Nz != LocDims[2]) {
    fprintf(stderr,"ComputeTimeStep error: x2 vector dims do not match\n");
    return FAIL;
  }
  if ((Nx+ghXl+ghXr) != ArrDims[0]) {
    fprintf(stderr,"ComputeTimeStep error: x0 vector sizes do not match\n");
    return FAIL;
  }
  if ((Ny+ghYl+ghYr) != ArrDims[1]) {
    fprintf(stderr,"ComputeTimeStep error: x1 vector sizes do not match\n");
    return FAIL;
  }
  if ((Nz+ghZl+ghZr) != ArrDims[2]) {
    fprintf(stderr,"ComputeTimeStep error: x2 vector sizes do not match\n");
    return FAIL;
  }

  // set internal dtfactor array based on user inputs and flag:
  float dtfactor[2];
  int i;
  for (i=0; i<2; i++)  dtfactor[i]=huge_number;
  if (flag == 0)  
    dtfactor[0] = dtfac[0];
  if (flag == 1) 
    dtfactor[1] = dtfac[1];
  if (flag == 2) {
    dtfactor[0] = dtfac[0];
    dtfactor[1] = dtfac[1];
  }

  // Set time step depending on how it has been set up by the user:
  //    If dtfactor is set for any species, compute maximum time step 
  //    as estimate allowing dtfactor relative change.  This relative 
  //    change is estimated as follows:
  //       dt_new = dt_old / relerr_fac
  //    where relerr_fac gives the ratio between an estimated 
  //    local truncation error and the desired relative change:
  //       relerr_fac = || (unew - uold) / w ||_p
  //    with the scaling vector w given by
  //       w = dtfactor*[sqrt(|unew*uold|) + atol]
  //    and where we have the following parameters:
  //       p - norm choice (input), 0->max norm, otherwise the p-norm
  //           **all p-norms here divide by the total number of cells**
  //       dtfactor - desired relative change per step (input)
  //       atol - 0.1 (assumes units are all normalized)
  float dt_est = huge_number;    // max time step (normalized units)
  float test   = min(dtfactor[0], dtfactor[1]);
  float atol   = 0.1;            // assumes values are normalized
  float *Eold, *Enew;
  if (test != huge_number) {

    // initialize variables
    float diff, w, tmp;
    int j, k, l;
    int x0len = Nx + ghXl + ghXr;
    int x1len = Ny + ghYl + ghYr;
    float loc_est[] = {0.0, 0.0};
    
    // perform local estimates for the Xray relative change
    if (dtfactor[0] != huge_number) {
      Eold = uold->GetData(0);
      Enew = unew->GetData(0);
      if (dtnorm > 0.0) {
	for (k=ghZl; k<Nz+ghZl; k++) 
	  for (j=ghYl; j<Ny+ghYl; j++)
	    for (i=ghXl; i<Nx+ghXl; i++) {
	      w = dtfactor[0]*(sqrt(fabs(Enew[(k*x1len + j)*x0len + i]
		                       * Eold[(k*x1len + j)*x0len + i])) 
			    + atol);
	      diff = Enew[(k*x1len + j)*x0len + i] 
		   - Eold[(k*x1len + j)*x0len + i];
	      tmp = fabs(diff/w);
	      loc_est[0] += POW(tmp,dtnorm);
	    }
      }
      else {
	for (k=ghZl; k<Nz+ghZl; k++) 
	  for (j=ghYl; j<Ny+ghYl; j++)
	    for (i=ghXl; i<Nx+ghXl; i++) {
	      w = dtfactor[0]*(sqrt(fabs(Enew[(k*x1len + j)*x0len + i]
				       * Eold[(k*x1len + j)*x0len + i])) 
			    + atol);
	      diff = Enew[(k*x1len + j)*x0len + i] 
  		   - Eold[(k*x1len + j)*x0len + i];
	      tmp = fabs(diff/w);
	      loc_est[0] = (loc_est[0] > tmp) ? loc_est[0] : tmp;
	    }
      }
    }

    // perform local estimates for UV relative change
    if (!XrayOnly) {
      if (dtfactor[1] != huge_number) {
	Eold = uold->GetData(1);
	Enew = unew->GetData(1);
	if (dtnorm > 0.0) {
	  for (k=ghZl; k<Nz+ghZl; k++) 
	    for (j=ghYl; j<Ny+ghYl; j++)
	      for (i=ghXl; i<Nx+ghXl; i++) {
		w = dtfactor[1]*(sqrt(fabs(Enew[(k*x1len + j)*x0len + i]
					 * Eold[(k*x1len + j)*x0len + i])) 
 				 + atol);
		diff = Enew[(k*x1len + j)*x0len + i] 
                     - Eold[(k*x1len + j)*x0len + i];
		tmp = fabs(diff/w);
		loc_est[1] += POW(tmp,dtnorm);
	      }
	}
	else {
	  for (k=ghZl; k<Nz+ghZl; k++) 
	    for (j=ghYl; j<Ny+ghYl; j++)
	      for (i=ghXl; i<Nx+ghXl; i++) {
		w = dtfactor[1]*(sqrt(fabs(Enew[(k*x1len + j)*x0len + i]
					 * Eold[(k*x1len + j)*x0len + i])) 
				 + atol);
		diff = Enew[(k*x1len + j)*x0len + i] 
                     - Eold[(k*x1len + j)*x0len + i];
		tmp = fabs(diff/w);
		loc_est[1] = (loc_est[1] > tmp) ? loc_est[1] : tmp;
	      }
	}
      }
    }

    // communicate to obtain overall sum/max
    float glob_est[2];
    int Nglobal = GlobDims[0]*GlobDims[1]*GlobDims[2];
#ifdef USE_MPI
    if (Nglobal == Nx*Ny*Nz) 
      for (l=0; l<2; l++)  glob_est[l] = loc_est[l];
    else {
      MPI_Datatype DataType = (sizeof(float) == 4) ? MPI_FLOAT : MPI_DOUBLE;
      MPI_Arg vars = 2;
      if (dtnorm > 0.0) 
	MPI_Allreduce(&loc_est,&glob_est,vars,DataType,MPI_SUM,MPI_COMM_WORLD);
      else
	MPI_Allreduce(&loc_est,&glob_est,vars,DataType,MPI_MAX,MPI_COMM_WORLD);
    }
#else
    for (l=0; l<2; l++)  glob_est[l] = loc_est[l];
#endif

    // compute overall norms
    if (dtnorm > 0.0) 
      for (l=0; l<2; l++) {
	glob_est[l] /= Nglobal;
	glob_est[l] = POW(glob_est[l],1.0/dtnorm);
      }

    // compute variable-specific time step estimates (physical units)
    float dt_est_var[2];
    for (l=0; l<2; l++) {
      dt_est_var[l] = (glob_est[l] == 0.0) ? huge_number : dt/glob_est[l];
      dt_est_var[l] = min(dt_est_var[l], huge_number);
    }

    // set estimated time step as minimum of component time steps
    dt_est = maxdt;    // max time step estimate (scaled units)
    for (l=0; l<2; l++) 
      dt_est = min(dt_est, dt_est_var[l]);

    // account for min/max time step size (according to user)
    dt_est = max(dt_est, mindt);
    dt_est = min(dt_est, maxdt);

    // if (debug) {
    //   if (XrayOnly) {
    // 	printf("  DualFLD_ComputeTimestep: Xray dt_est = %8.2e\n", dt_est_var[0]);
    //   } else {
    // 	printf("  DualFLD_ComputeTimestep: (Xray, UV) dt_est = (");
    // 	for (l=0; l<2; l++) {
    // 	  if (dt_est_var[l] == huge_number/TimeUnits)
    // 	    printf(" -------- ");
    // 	  else  
    // 	    printf(" %8.2e ",dt_est_var[l]);
    // 	}
    // 	printf(")\n");
    //   }
    // }
  }

  // account for min/max time step size (according to user)
  dt_est = max(dt_est, mindt);
  dt_est = min(dt_est, maxdt);

  return dt_est;
}

#endif
